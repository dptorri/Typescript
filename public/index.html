<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>TYpescript</title>
</head>
<body>
    <h1>Typescript - Tutorial</h1>
    <h2>Built-int types</h2>
    <p>The new TypeScript syntax is a natural evolution from ES5, we still use var but now we can
            optionally provide the variable type along with its name:</p>
    <code>var myName: string;</code>
    <p>When declaring functions we can use types for arguments and return values:</p>
    <code>function hiThere(name: string): string {
        return "Hi there "+ name;
    }
    </code>
    <p>here the argument <em>(name: string)</em> name is a string and the return value of the function<em>' : string '</em> is also a string</p>
    <h2>Variable types</h2>
    <h3>String</h3>
    <code>var nameHero : string = 'Ironman';</code>
    <h3>Number</h3>
    <p>Represented by default as float</p>
    <code>var suitsHero : number = '46';</code>
    <h3>Boolean</h3>
    <code>var isMarried : boolean = false;</code>
    <h3>Array</h3>
    <p>Array are declared with the array type, but also the type of the objects inside must be defined</p>
    <code>var heroEnemies : Array<string> = ['ultron', 'thanos'];<br>
        var heroEnemies : string[] = ['ultron', 'thanos'];<br>
    </code>
    <h3>Enums</h3>
    <p>fix list the roles a hero can have</p>
    <code>enum Role {Billionare,Inventor,Playboy}<br>
    var role: Role = Role.Inventor</code>
    <p>the default value is 0, so it would be 0,1,2 in our example, but it can be increased with Inventor = 5</p>
    <code>enum Role {Billionare,Inventor = 5,Playboy}<br>
        var role2 : Role = Role.Playboy;<br>
    console.log(role2);// 6</code>
    <p>Note that Billionare got 0 as the default key as increases only from Inventor onwards</p>
    <h3>Any</h3>
    <p>The default type if none is given</p>
    <code>var something : any = 'asrting';</code>
    <h4>Void</h4>
    <p>Useful in functions that do not return a value. (e.g. functions that set a variable)</p>
    <code>function setName(name: string): void {<br>
        &emsp;&emsp;&emsp;this.nameHero = name;<br>
    }</code>
    <h2>Classes</h2>
    <p>we use the class keyword, a name and a body. Classes can have properties, methods and constructors</p>
    <code>class Villain{<br>}</code>
    <h3>Properties</h3>
    <p>They define a data attached to an instance of a class</p>
    <code>class Villain{<br>
    &emsp;&emsp;&emsp;name: string;<br>
    &emsp;&emsp;&emsp;power: string;<br>
    &emsp;&emsp;&emsp;age: number;<br>
    }</code>
    <h3>Methods</h3>
    <code>greet(){<br>
    &emsp;&emsp;&emsp;console.log('Hello '+this.name);
    <br>}</code>
    <p>in this case we are returning void as a return type of this function, which is a valid option.
        <br>You can declare a variable and instatiate on the same line <br>
    </p>
    <code>var o : villain = new villain();</code>
    <h3>Contructors</h3>
    <p>If not declared the constructor will be created automatically</p>
    <code>class villain {<br>&emsp;&emsp;&emsp;constructor(){<br>&emsp;&emsp;&emsp;}<br>}<br>var v = new villain(); </code>
    <p>in Typescript you can only have one construtor per class. In ES6 you can have more as long as they have a different number of parameters</p>
    <pre>
    class Villain {
           name: string;
           power: string;
           age: number;
        
            constructor(name: string, power:string, age: number) {
                this.name = name;
                this.power = power;
                this. age = age;
            }
            stats() {
                console.log(
                    " Hero name : ",this.name,
                    " Hero power : ",this.power,
                    " Hero age :",this.age
                    );
            }
            bornIn(thisyear: number): number {
                return thisyear-this.age;
            }
        
    }
    </pre>
    <h3>Inheritance</h3>
    <p>TypeScript fully supports inheritance and, unlike ES5, it’s built into the core language. Inheritance
            is achieved through the extends keyword.</p>
    <pre>class Report {
            data: Array<string>;
                constructor(data: Array<string>) {
                    this.data = data;
                }
                run() {
                    this.data.forEach(function(line) { console.log(line); });
                }
            }
        </pre>
        <p>This report has a property data which is an Array of strings. When we call run we loop over each
                element of data and print them out using console.log<br>
                To reuse that behavior from the Report class we can use inheritance with the extends keyword:</p>
                <pre>
    class TabbedReport extends Report {
        headers: Array<string>;
            constructor(headers: string[], values: string[]) {
                super(values)
                this.headers = headers;
            }
        
        run() {
            console.log(this.headers);
            super.run();
        }
    }
                </pre>
<h3>Utilities</h3>
<p>ES6, and by extension TypeScript provides a number of syntax features that make programming
   really enjoyable. Two important ones are:<br>
   • fat arrow function syntax<br>
   • template strings<br>
In ES5
</p>
<pre>
//ES5 example
var dataES5 = ['black widow','storm','jane'];
data.forEach(
    function(line) 
    {console.log(line); 
    });

//Typescript Fat Arrow
var dataTypescript = ['wonder','louise','pepper'];
data.forEach(
    (line) =>
    console.log(line)
    );
)
</pre>
<p>Another great improvement is that the => syntax shares the 'this' as the surrounding code
<br>no longer is needed to declare [var self=this;] to call other properties of an object.
</p>
<pre>
    //ES5 usual case of declaring a [var self = this;]
    var daniel = {
        name: 'Daniel',
        laptops: ['hp','acer'],
        printLaptops: function() {
            var self = this;
            this.laptops.forEach(function(l) {
                //this.name is undefined ergo the fix
                console.log(self.name+" uses a "+l);
            });
        }
    };

    //Typescript
    var kathi = {
        name: 'Kathi',
        laptops: ['mac','compaq'],
        printLaptops: function() {
            this.laptops.forEach( (l) => {
                console.log(this.name+" uses a "+l);
            });
        }
    };
</pre>
<h3>Template Strings</h3>
<p>In ES6 new template strings were introduced. The two great features of template strings are<br>
        1. Variables within strings (without being forced to concatenate with +) and<br>
        2. Multi-line strings</p>
<pre>
    //Variables within strings
    var name = 'Louise';
    var surname = 'Lane';

    //interpolate a string
    var hiThere = `Hi there Ms. ${surname}`;

    console.log(hiThere);
</pre>                
<p>you must enclose your string in backticks not single or double
quotes.</p>
<pre>
    //Multiline strings great for templates in Angular!!!
    var fullName = `
    < div>
        < h2>Ms Lane< /h2>
        < h3>Louisa Lane< /h3>
    < /div>
    `;
</pre>
<p>
        There are a variety of other features in TypeScript/ES6 such as:
        <br>• Interfaces
        <br>• Generics
        <br>• Importing and Exporting Modules
        <br>• Decorators
        <br>• Destructuring
</p>


    <!--
    <div id="root">
        </div>
        <script src="bundle.js"></script>-->
</body>
</html>